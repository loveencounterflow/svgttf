{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../../src/experiments/dumb-svg-parser.coffee"
  ],
  "names": [],
  "mappings": "AAE4G;EAAA;AAAA,MAAA;;EAC5G,IAAC,CAAA,KAAD,GAAS,QAAA,CAAE,QAAF,CAAA,EAAA;;AACT,QAAA,QAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,EAAA;IACE,EAAA,GAAK,QAAQ,CAAC,KAAT,CAAe,qBAAf;IACL,KAAA,4CAAA;;MACE,QAAA,GAAW,KAAK,CAAC,KAAN,CAAY,uBAAZ;MACX,KAAS,0FAAT;QACE,QAAQ,CAAE,CAAF,CAAR,GAAgB,UAAA,CAAW,QAAQ,CAAE,CAAF,CAAnB;MADlB;MAEA,EAAE,CAAE,CAAF,CAAF,GAAU;IAJZ;AAKA,WAAO;EARA,EADmG;;;EAY5G,IAAC,CAAA,KAAD,GAAS,QAAA,CAAE,EAAF,EAAM,MAAN,EAAc,WAAW,IAAzB,CAAA;AACT,QAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,EAAA;IAAE,IAAG,CAAM,gBAAN,CAAA,IAAqB,CAAE,QAAA,KAAY,MAAd,CAAxB;MACE,KAAA,4CAAA;;QACE,KAAS,uFAAT;UACE,KAAK,CAAE,CAAF,CAAL,IAAc;QADhB;MADF,CADF;KAAA,MAAA;MAKE,KAAA,8CAAA;;QACE,KAAS,4FAAT;UACE,WAAG,KAAK,CAAE,CAAF,gBAAS,MAAd,UAAH;YACE,KAAK,CAAE,CAAF,CAAL,IAAc;AACd,qBAFF;;UAGA,KAAK,CAAE,CAAF,CAAL,IAAiB,CAAE,CAAA,GAAI,CAAJ,KAAS,CAAX,CAAH,GAAuB,QAAvB,GAAqC;QAJrD;MADF,CALF;;AAWA,WAAO;EAZA,EAZmG;;;EA2B5G,IAAC,CAAA,OAAD,GAAW,QAAA,CAAE,EAAF,CAAA;AAAS,QAAA;WAAC;;AAAE;MAAA,KAAA,oCAAA;;qBAAA,KAAK,CAAC,IAAN,CAAW,GAAX;MAAA,CAAA;;QAAF,CAAkC,CAAC,IAAnC,CAAwC,GAAxC;EAAV,EA3BiG;;;EA8B5G,IAAC,CAAA,kBAAD,GAAsB,QAAA,CAAE,EAAF,CAAA;AACtB,QAAA,CAAA,EAAA,MAAA;;;IAEE,CAAA,GAAI,IAAC,CAAA,OAAD,CAAS,EAAT;AACJ,WAAA,IAAA;MACE,MAAA,GAAU,CAAC,CAAC;MACZ,CAAA,GAAU,CAAC,CAAC,OAAF,CAAU,8BAAV,EAA0C,YAA1C;MACV,IAAS,CAAC,CAAC,MAAF,KAAY,MAArB;AAAA,cAAA;;IAHF;AAIA,WAAO;EARa;;EA9BsF;;;;AAAA",
  "sourcesContent": [
    "\n\n#-----------------------------------------------------------------------------------------------------------\n@parse = ( pathdata ) ->\n  ### thx to https://stackoverflow.com/a/17018012 ###\n  me = pathdata.match /([a-z]+[-.,\\d ]*)/gi\n  for piece, i in me\n    elements = piece.match /([a-z]+|-?[.\\d]*\\d)/gi\n    for j in [ 1 ... elements.length ]\n      elements[ j ] = parseFloat elements[ j ]\n    me[ i ] = elements\n  return me\n\n#-----------------------------------------------------------------------------------------------------------\n@scale = ( me, factor, factor_y = null ) ->\n  if ( not factor_y? ) or ( factor_y is factor )\n    for piece, i in me\n      for j in [ 1 ... piece.length ]\n        piece[ j ] *= factor\n  else\n    for piece, i in me\n      for j in [ 1 ... piece.length ]\n        if piece[ 0 ] in 'Vv'\n          piece[ 1 ] *= factor_y\n          continue\n        piece[ j ] *= if ( j % 2 is 0 ) then factor_y else factor\n  return me\n\n#-----------------------------------------------------------------------------------------------------------\n@as_text = ( me ) -> ( piece.join ' ' for piece in me ).join ' '\n\n#-----------------------------------------------------------------------------------------------------------\n@as_compressed_text = ( me ) ->\n  ### NOTE: using lookbehind, lookahead entails 10% performance loss ###\n  # R       = R.replace /\\x20(?=-)|(?<=\\d)\\x20(?=\\D)|(?<=\\D)\\x20(?=\\d)/g, ''\n  R = @as_text me\n  loop\n    length  = R.length\n    R       = R.replace /\\x20(-)|(\\d) (\\D)|(\\D) (\\d)/g, '$1$2$3$4$5'\n    break if R.length is length\n  return R\n\n# path_pieces = parse pathdata\n# info path_pieces\n# info @scale path_pieces, 2\n# info @as_text @scale path_pieces, 2\n"
  ]
}