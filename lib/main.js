// Generated by CoffeeScript 1.8.0
(function() {
  var CHR, DOMParser, SvgPath, T, TEXT, TRM, TYPES, alert, badge, debug, echo, em_size, glob, help, info, log, module, njs_fs, njs_path, options, rpr, svg2ttf, urge, warn, whisper, xpath,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  DOMParser = (require('xmldom-silent')).DOMParser;

  xpath = require('xpath');

  CHR = require('coffeenode-chr');

  TRM = require('coffeenode-trm');

  TEXT = require('coffeenode-text');

  TYPES = require('coffeenode-types');

  rpr = TRM.rpr.bind(TRM);

  badge = 'svg2ttf/svg-to-svg-font';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  SvgPath = require('svgpath');


  /* https://github.com/loveencounterflow/coffeenode-teacup */

  T = require('coffeenode-teacup');


  /* https://github.com/isaacs/node-glob */

  glob = require('glob');


  /* https://github.com/fontello/svg2ttf */

  svg2ttf = require('svg2ttf');

  module = 36;

  em_size = 4096;

  options = {

    /* Coordinates of first glyph outline: */
    'offset': [module * 4, module * 4],

    /* Ad hoc correction: */
    'correction': [0, module * 0.075],

    /* Size of grid and font design size: */
    'module': module,

    /* Number of glyph rows between two rulers plus one: */
    'block-height': 9,

    /* CID of first glyph outline: */
    'row-length': 16,
    'em-size': em_size,
    'ascent': +0.8 * em_size,
    'descent': -0.2 * em_size
  };

  options['scale'] = em_size / module;

  this.main = function(settings) {
    var actual_row, block_count, center, cid, cid0, col, correction, doc, dx, dy, entry, fallback, fallback_count, fallback_source, filename, font_name, glyph_count, glyphs, input_routes, local_glyph_count, local_max_cid, local_min_cid, match, max_cid, max_cid_hex, min_cid, min_cid_hex, parser, path, path_count, paths, prefix, route, row, select, selector, source, svgfont, transform, x, y, _, _i, _j, _k, _len, _len1;
    input_routes = settings['input-routes'];
    glyphs = {};
    glyph_count = 0;
    parser = new DOMParser();
    select = xpath.useNamespaces({
      'SVG': 'http://www.w3.org/2000/svg'
    });
    selector = '//SVG:svg/SVG:path';
    fallback = null;
    fallback_count = 0;
    fallback_source = null;
    min_cid = +Infinity;
    max_cid = -Infinity;
    font_name = settings['font-name'];
    correction = options['correction'];
    info("reading files for font " + (rpr(font_name)));
    for (_i = 0, _len = input_routes.length; _i < _len; _i++) {
      route = input_routes[_i];
      local_min_cid = +Infinity;
      local_max_cid = -Infinity;
      local_glyph_count = 0;
      filename = njs_path.basename(route);
      cid0 = this._cid0_from_route(route);
      source = njs_fs.readFileSync(route, {
        encoding: 'utf-8'
      });
      doc = parser.parseFromString(source, 'application/xml');
      paths = select(selector, doc);
      path_count = paths.length;
      whisper("" + filename + ": found " + paths.length + " outlines");
      for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
        path = paths[_j];
        if (((transform = path.getAttribute('transform')) != null) && transform.length > 0) {
          match = transform.match(/^translate\(([-+.0-9]+),([-+.0-9]+)\)$/);
          if (match == null) {
            throw new Error("unable to parse transform " + (rpr(transform)));
          }
          _ = match[0], x = match[1], y = match[2];
          x = parseFloat(x, 10);
          y = parseFloat(y, 10);
          if (!((TYPES.isa_number(x)) && (TYPES.isa_number(y)))) {
            throw new Error("unable to parse transform " + (rpr(transform)));
          }
          transform = ['translate', x, y];
        } else {
          transform = null;
        }
        path = (new SvgPath(path.getAttribute('d'))).abs();
        if (transform != null) {
          path = path.translate(transform[1], transform[2]);
        }
        if (correction != null) {
          path = path.translate(correction[0], correction[1]);
        }
        center = this.center_from_absolute_path(path);
        x = center[0], y = center[1];
        x -= options['offset'][0];
        y -= options['offset'][1];
        col = Math.floor(x / options['module']);
        row = Math.floor(y / options['module']);
        block_count = Math.floor(row / options['block-height']);
        actual_row = row - block_count;
        cid = cid0 + actual_row * options['row-length'] + col;
        dx = -(col * options['module']) - options['offset'][0];
        dy = -(row * options['module']) - options['offset'][1];
        path = path.translate(dx, dy).scale(1, -1).translate(0, options['module']).scale(options['scale']).round(0);
        if (cid < cid0) {
          prefix = fallback != null ? 're-' : '';
          fallback = path;
          fallback_source = filename;
          whisper("" + filename + ": " + prefix + "assigned fallback");
        } else {
          min_cid = Math.min(min_cid, cid);
          max_cid = Math.max(max_cid, cid);
          local_min_cid = Math.min(local_min_cid, cid);
          local_max_cid = Math.max(local_max_cid, cid);
          if (glyphs[cid] != null) {
            warn("" + filename + ": duplicate CID: 0x" + (cid.toString(16)));
          } else {
            glyphs[cid] = [cid, path];
            glyph_count += 1;
            local_glyph_count += 1;
          }
        }
      }
      if (local_glyph_count > 0) {
        min_cid_hex = '0x' + local_min_cid.toString(16);
        max_cid_hex = '0x' + local_max_cid.toString(16);
        help("" + filename + ": added " + local_glyph_count + " glyph outlines to [ " + min_cid_hex + " .. " + max_cid_hex + " ]");
      } else {
        warn("" + filename + ": no glyphs found");
      }
    }
    if (glyph_count === 0) {
      warn("no glyphs found; terminating");
      process.exit(1);
    }
    for (cid = _k = min_cid; min_cid <= max_cid ? _k <= max_cid : _k >= max_cid; cid = min_cid <= max_cid ? ++_k : --_k) {
      if (glyphs[cid] == null) {
        glyphs[cid] = [cid, fallback];
        fallback_count += 1;
      }
    }
    if (fallback_count > 0) {
      whisper("filled " + fallback_count + " positions with fallback outline from " + fallback_source);
    }
    min_cid_hex = '0x' + min_cid.toString(16);
    max_cid_hex = '0x' + max_cid.toString(16);
    help("added " + glyph_count + " glyph outlines to [ " + min_cid_hex + " .. " + max_cid_hex + " ]");
    glyphs = (function() {
      var _results;
      _results = [];
      for (_ in glyphs) {
        entry = glyphs[_];
        _results.push(entry);
      }
      return _results;
    })();
    glyphs.sort(function(a, b) {
      if (a[0] > b[0]) {
        return +1;
      }
      if (a[0] < b[0]) {
        return -1;
      }
      return 0;
    });
    svgfont = this.svgfont_from_name_and_glyphs(font_name, glyphs);
    return this._write_ttf(svgfont, settings);
  };

  this._write_ttf = function(svgfont, settings) {
    var output_route;
    output_route = settings['output-route'];

    /* svg2ttf has a strange API and returns a buffer that isn't a `Buffer`... */
    njs_fs.writeFileSync(output_route, new Buffer((svg2ttf(svgfont)).buffer));
    return help("output written to " + output_route);
  };

  this.center_from_absolute_path = function(path) {
    return this.center_from_absolute_points(this.points_from_absolute_path(path));
  };

  this.center_from_absolute_points = function(path) {
    var node_count, sum_x, sum_y, x, y, _i, _len, _ref;
    node_count = path.length;
    sum_x = 0;
    sum_y = 0;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      _ref = path[_i], x = _ref[0], y = _ref[1];
      if (!((x != null) && (y != null))) {
        throw new Error("found undefined points in path");
      }
      sum_x += x;
      sum_y += y;
    }
    return [sum_x / node_count, sum_y / node_count];
  };

  this.points_from_absolute_path = function(path) {
    var R, command, idx, last_x, last_y, node, x, xy, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    R = [];
    _ref = path['segments'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      command = node[0], xy = 2 <= node.length ? __slice.call(node, 1) : [];

      /* Ignore closepath command: */
      if (/^[zZ]$/.test(command)) {
        continue;
      }
      if (!/^[MLHVCSQTA]$/.test(command)) {
        throw new Error("unknown command " + (rpr(command)) + " in path " + (rpr(path)));
      }
      switch (command) {
        case 'H':
          _ref1 = [xy[0], last_y], x = _ref1[0], y = _ref1[1];
          R.push([x, y]);
          break;
        case 'V':
          _ref2 = [last_x, xy[0]], x = _ref2[0], y = _ref2[1];
          R.push([x, y]);
          break;
        case 'M':
        case 'L':
          for (idx = _j = 0, _ref3 = xy.length; _j < _ref3; idx = _j += +2) {
            _ref4 = [xy[idx], xy[idx + 1]], x = _ref4[0], y = _ref4[1];
            R.push([x, y]);
          }
          break;
        case 'C':
          for (idx = _k = 0, _ref5 = xy.length; _k < _ref5; idx = _k += +6) {
            _ref6 = [xy[idx + 4], xy[idx + 5]], x = _ref6[0], y = _ref6[1];
            R.push([x, y]);
          }
          break;
        case 'S':
          for (idx = _l = 0, _ref7 = xy.length; _l < _ref7; idx = _l += +4) {
            _ref8 = [xy[idx + 2], xy[idx + 3]], x = _ref8[0], y = _ref8[1];
            R.push([x, y]);
          }
          break;
        case 'Q':
          warn(rpr(path));
          throw new Error("quadratic splines (SVG path commands `q` and `Q` not yet supported; in case you're\nworking with Inkscape, identify the offending path and nudge one of its control points\nslightly and save the document; this will cause Inkscape to convert the outline to a\ncubic spline.\n\nsee http://inkscape.13.x6.nabble.com/Quadratic-beziers-td2856790.html");
          break;
        default:
          warn(rpr(path));
          throw new Error("unknown command " + (rpr(command)) + " in path");
      }
      last_x = x;
      last_y = y;
    }
    return R;
  };

  T.SVG = function() {
    var P, Q;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Q = {
      'xmlns': 'http://www.w3.org/2000/svg'
    };
    return T.TAG.apply(T, ['svg', Q].concat(__slice.call(P)));
  };

  T.DEFS = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return T.TAG.apply(T, ['defs'].concat(__slice.call(P)));
  };

  T.FONT = function() {
    var P, Q, font_name;
    font_name = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    Q = {
      'id': font_name,
      'horiz-adv-x': options['module'] * options['scale']
    };
    return T.TAG.apply(T, ['font', Q].concat(__slice.call(P)));
  };

  T.FONT_FACE = function(font_family) {
    var Q;
    Q = {
      'font-family': font_family,
      'units-per-em': options['module'] * options['scale'],

      /* TAINT probably wrong values */
      'ascent': options['ascent'],
      'descent': options['descent']
    };

    /* TAINT kludge */
    return T.RAW((T.render((function(_this) {
      return function() {
        return T.TAG('font-face', Q);
      };
    })(this))).replace(/><\/font-face>$/, ' />'));
  };

  T.GLYPH = function(cid, path) {
    var Q;
    Q = {
      unicode: CHR.as_chr(cid),
      d: T._rpr_path(path)
    };
    return T.TAG('glyph', Q);
  };

  T.MARKER = function(xy, r) {
    if (r == null) {
      r = 10;
    }
    return T.TAG('circle', {
      cx: xy[0],
      cy: xy[1],
      r: r,
      fill: '#f00'
    });
  };

  T._rpr_path = function(path) {
    var s;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = path['segments'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s[0] + s.slice(1).join(','));
      }
      return _results;
    })()).join(' ');
  };

  T.path = function(path) {
    var path_txt;
    path_txt = T._rpr_path(path);
    return T.TAG('path', {
      d: path_txt,
      fill: '#000'
    });
  };

  this.svgfont_from_name_and_glyphs = function(font_name, glyphs) {
    return T.render((function(_this) {
      return function() {
        T.RAW("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");

        /* must preserve space at end of DOCTYPE declaration */
        T.RAW("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n");
        return T.SVG(function() {
          T.TEXT('\n');
          T.DEFS(function() {
            T.TEXT('\n');
            T.FONT(font_name, function() {
              var cid, path, _i, _len, _ref, _results;
              T.TEXT('\n');
              T.FONT_FACE(font_name);
              T.TEXT('\n');
              _results = [];
              for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
                _ref = glyphs[_i], cid = _ref[0], path = _ref[1];
                T.RAW("<!-- " + (cid.toString(16)) + " -->");
                T.GLYPH(cid, path);
                _results.push(T.TEXT('\n'));
              }
              return _results;
            });
            return T.TEXT('\n');
          });
          return T.TEXT('\n');
        });
      };
    })(this));
    return null;
  };

  this._compile_settings = function(cli_options) {
    var R, name, _i, _len, _ref;
    R = {
      'overwrite': cli_options['--force'],
      'input-format': cli_options['<input-format>'],
      'output-format': cli_options['<output-format>'],
      'input-directory': cli_options['<input-directory>'],
      'font-name': cli_options['<font-name>'],
      'output-directory': cli_options['<output-directory>']
    };
    this._get_input_routes(R);
    this._get_output_route(R);
    _ref = ((function() {
      var _results;
      _results = [];
      for (name in R) {
        _results.push(name);
      }
      return _results;
    })()).sort();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      whisper(TEXT.flush_left(name + ':', 20), rpr(R[name]));
    }
    return R;
  };

  this._get_output_route = function(settings) {
    var R, extension, font_name, output, output_format;
    output_format = settings['output-format'];
    output = settings['output-directory'];
    font_name = settings['font-name'];
    switch (output_format) {
      case 'ttf':
        extension = settings['output-extension'] = 'ttf';
        break;
      default:
        throw new Error("output format not supported: " + (rpr(output_format)));
    }
    R = settings['output-route'] = this._join_routes(output, "" + font_name + "." + extension);
    if ((!settings['overwrite']) && njs_fs.existsSync(R)) {
      warn("target already exists: " + R);
      help("either");
      help("  * correct your input");
      help("  * or remove target first");
      help("  * or use the `-f` option");
      throw new Error("target exists");
    }
  };

  this._get_input_routes = function(settings) {
    var R, extension, font_name, input_directory, input_format, name_glob, route_glob;
    input_format = settings['input-format'];
    input_directory = settings['input-directory'];
    font_name = settings['font-name'];
    switch (input_format) {
      case 'svg':
      case 'svgfont':
        extension = settings['input-extension'] = 'svg';
        break;
      default:
        throw new Error("input format not supported: " + (rpr(input_format)));
    }
    name_glob = "" + font_name + "-+([0-9a-f])." + extension;
    route_glob = settings['input-glob'] = this._join_routes(input_directory, name_glob);
    R = settings['input-routes'] = glob.sync(route_glob);
    return R;
  };

  this._font_name_from_route = function(route) {
    var R, match;
    match = route.match(/([^\/]+)-[0-9a-f]+?\.svg$/);
    if (match == null) {
      throw new Error("unable to parse route " + (rpr(route)));
    }
    R = match[1];
    if (!(R.length > 0)) {
      throw new Error("illegal font name in route " + (rpr(route)));
    }
    return R;
  };

  this._cid0_from_route = function(route) {
    var R, match;
    match = route.match(/-([0-9a-f]+)\.svg$/);
    if (match == null) {
      throw new Error("unable to parse route " + (rpr(route)));
    }
    R = parseInt(match[1], 16);
    if (!((0x0000 <= R && R <= 0x10ffff))) {
      throw new Error("illegal CID in route " + (rpr(route)));
    }
    return R;
  };

  this.demo = function() {
    var d, path;
    d = "M168,525.89c38,36,48,48,46,81s5,47-46,52 s-88,35-91-27s-21-73,11-92S168,525.89,168,525.89z";
    path = new SvgPath(d).scale(0.5).translate(100, 200).abs().round(0);
    debug(JSON.stringify(path));
    help(this.points_from_absolute_path(path));
    help(this.center_from_absolute_path(path));
    return debug(this.f(path));
  };

  this._join_routes = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return njs_path.resolve(process.cwd(), njs_path.join.apply(njs_path, P));
  };

  if (module.parent == null) {
    (function(_this) {
      return (function() {
        var cli_options, docopt, usage, version;
        docopt = (require('coffeenode-docopt')).docopt;
        version = (require('../package.json'))['version'];
        usage = "Usage: svgttf [-f] <input-directory> <font-name> <input-format> <output-directory> <output-format>\n\n      Currently the only allowed arguments are:\n      <input-format>:     must be `svg`\n      <output-format>:    must be `ttf`\n      <input-directory>:  route to directory with your SVG design sheets\n      <font-name>:        name of your font\n      <output-directory>: directory where output is written to\n\n      Please observe:\n\n      * The structure of your SVG design sheets must follow the guidelines as detailed in the\n        project README.md.\n\n      * Your font files must be named like `myfontname-e100.svg`, `myfontname-e200.svg`, ..., i.e.\n        each filename has the font name first and ends with an indication of the first CID (Unicode\n        codepoint, in hexadecimal) and the filename extension `.svg`.\n\n      * Use `.` (dot) to get a file named `myfontname.ttf` in the current directory.\n\n      * `svgttf` will not overwrite an existing file unless given the `--force` (or `-f`) option.\n\nOptions:\n  -h, --help\n  -v, --version\n  -f, --force";
        cli_options = docopt(usage, {
          version: version,
          help: function(left, collected) {
            return help('\n' + usage);
          }
        });
        if (cli_options != null) {
          return _this.main(_this._compile_settings(cli_options));
        }
      });
    })(this)();
  }

}).call(this);
